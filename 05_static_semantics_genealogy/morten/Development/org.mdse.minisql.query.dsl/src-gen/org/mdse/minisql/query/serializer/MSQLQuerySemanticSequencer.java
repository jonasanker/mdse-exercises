/*
 * generated by Xtext 2.20.0
 */
package org.mdse.minisql.query.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.mdse.minisql.query.AllColumnsWhatDirective;
import org.mdse.minisql.query.ArithmeticExpression;
import org.mdse.minisql.query.BinaryLogicalExpression;
import org.mdse.minisql.query.BooleanLiteral;
import org.mdse.minisql.query.ColumnReference;
import org.mdse.minisql.query.ComparativeExpression;
import org.mdse.minisql.query.FromClause;
import org.mdse.minisql.query.IntegerLiteral;
import org.mdse.minisql.query.OrderByClause;
import org.mdse.minisql.query.OrderDirective;
import org.mdse.minisql.query.QueryPackage;
import org.mdse.minisql.query.SelectQuery;
import org.mdse.minisql.query.SingleColumnWhatDirective;
import org.mdse.minisql.query.StringLiteral;
import org.mdse.minisql.query.TableReference;
import org.mdse.minisql.query.UnaryLogicalExpression;
import org.mdse.minisql.query.WhatClause;
import org.mdse.minisql.query.WhereClause;
import org.mdse.minisql.query.services.MSQLQueryGrammarAccess;

@SuppressWarnings("all")
public class MSQLQuerySemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MSQLQueryGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == QueryPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case QueryPackage.ALL_COLUMNS_WHAT_DIRECTIVE:
				sequence_AllColumnsWhatDirective(context, (AllColumnsWhatDirective) semanticObject); 
				return; 
			case QueryPackage.ARITHMETIC_EXPRESSION:
				sequence_AdditiveExpression_MultiplicativeExpression(context, (ArithmeticExpression) semanticObject); 
				return; 
			case QueryPackage.BINARY_LOGICAL_EXPRESSION:
				sequence_AndExpression_OrExpression(context, (BinaryLogicalExpression) semanticObject); 
				return; 
			case QueryPackage.BOOLEAN_LITERAL:
				sequence_BooleanLiteral(context, (BooleanLiteral) semanticObject); 
				return; 
			case QueryPackage.COLUMN_REFERENCE:
				sequence_ColumnReference(context, (ColumnReference) semanticObject); 
				return; 
			case QueryPackage.COMPARATIVE_EXPRESSION:
				sequence_ComparativeExpression(context, (ComparativeExpression) semanticObject); 
				return; 
			case QueryPackage.FROM_CLAUSE:
				sequence_FromClause(context, (FromClause) semanticObject); 
				return; 
			case QueryPackage.INTEGER_LITERAL:
				sequence_IntegerLiteral(context, (IntegerLiteral) semanticObject); 
				return; 
			case QueryPackage.ORDER_BY_CLAUSE:
				sequence_OrderByClause(context, (OrderByClause) semanticObject); 
				return; 
			case QueryPackage.ORDER_DIRECTIVE:
				sequence_OrderDirective(context, (OrderDirective) semanticObject); 
				return; 
			case QueryPackage.SELECT_QUERY:
				sequence_SelectQuery(context, (SelectQuery) semanticObject); 
				return; 
			case QueryPackage.SINGLE_COLUMN_WHAT_DIRECTIVE:
				sequence_SingleColumnWhatDirective(context, (SingleColumnWhatDirective) semanticObject); 
				return; 
			case QueryPackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case QueryPackage.TABLE_REFERENCE:
				sequence_TableReference(context, (TableReference) semanticObject); 
				return; 
			case QueryPackage.UNARY_LOGICAL_EXPRESSION:
				sequence_NotExpression(context, (UnaryLogicalExpression) semanticObject); 
				return; 
			case QueryPackage.WHAT_CLAUSE:
				sequence_WhatClause(context, (WhatClause) semanticObject); 
				return; 
			case QueryPackage.WHERE_CLAUSE:
				sequence_WhereClause(context, (WhereClause) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expression returns ArithmeticExpression
	 *     OrExpression returns ArithmeticExpression
	 *     OrExpression.BinaryLogicalExpression_1_0 returns ArithmeticExpression
	 *     AndExpression returns ArithmeticExpression
	 *     AndExpression.BinaryLogicalExpression_1_0 returns ArithmeticExpression
	 *     AndOperand returns ArithmeticExpression
	 *     ComparativeExpression returns ArithmeticExpression
	 *     ComparativeExpression.ComparativeExpression_1_0 returns ArithmeticExpression
	 *     AdditiveExpression returns ArithmeticExpression
	 *     AdditiveExpression.ArithmeticExpression_1_0 returns ArithmeticExpression
	 *     MultiplicativeExpression returns ArithmeticExpression
	 *     MultiplicativeExpression.ArithmeticExpression_1_0 returns ArithmeticExpression
	 *     AtomicExpression returns ArithmeticExpression
	 *
	 * Constraint:
	 *     (
	 *         (expression1=AdditiveExpression_ArithmeticExpression_1_0 operator=AdditiveOperator expression2=MultiplicativeExpression) | 
	 *         (expression1=MultiplicativeExpression_ArithmeticExpression_1_0 operator=MultiplicativeOperator expression2=AtomicExpression)
	 *     )
	 */
	protected void sequence_AdditiveExpression_MultiplicativeExpression(ISerializationContext context, ArithmeticExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WhatDirective returns AllColumnsWhatDirective
	 *     AllColumnsWhatDirective returns AllColumnsWhatDirective
	 *
	 * Constraint:
	 *     {AllColumnsWhatDirective}
	 */
	protected void sequence_AllColumnsWhatDirective(ISerializationContext context, AllColumnsWhatDirective semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BinaryLogicalExpression
	 *     OrExpression returns BinaryLogicalExpression
	 *     OrExpression.BinaryLogicalExpression_1_0 returns BinaryLogicalExpression
	 *     AndExpression returns BinaryLogicalExpression
	 *     AndExpression.BinaryLogicalExpression_1_0 returns BinaryLogicalExpression
	 *     AndOperand returns BinaryLogicalExpression
	 *     ComparativeExpression returns BinaryLogicalExpression
	 *     ComparativeExpression.ComparativeExpression_1_0 returns BinaryLogicalExpression
	 *     AdditiveExpression returns BinaryLogicalExpression
	 *     AdditiveExpression.ArithmeticExpression_1_0 returns BinaryLogicalExpression
	 *     MultiplicativeExpression returns BinaryLogicalExpression
	 *     MultiplicativeExpression.ArithmeticExpression_1_0 returns BinaryLogicalExpression
	 *     AtomicExpression returns BinaryLogicalExpression
	 *
	 * Constraint:
	 *     (
	 *         (expression1=OrExpression_BinaryLogicalExpression_1_0 operator=OrOperator expression2=AndExpression) | 
	 *         (expression1=AndExpression_BinaryLogicalExpression_1_0 operator=AndOperator expression2=AndOperand)
	 *     )
	 */
	protected void sequence_AndExpression_OrExpression(ISerializationContext context, BinaryLogicalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BooleanLiteral
	 *     OrExpression returns BooleanLiteral
	 *     OrExpression.BinaryLogicalExpression_1_0 returns BooleanLiteral
	 *     AndExpression returns BooleanLiteral
	 *     AndExpression.BinaryLogicalExpression_1_0 returns BooleanLiteral
	 *     AndOperand returns BooleanLiteral
	 *     ComparativeExpression returns BooleanLiteral
	 *     ComparativeExpression.ComparativeExpression_1_0 returns BooleanLiteral
	 *     AdditiveExpression returns BooleanLiteral
	 *     AdditiveExpression.ArithmeticExpression_1_0 returns BooleanLiteral
	 *     MultiplicativeExpression returns BooleanLiteral
	 *     MultiplicativeExpression.ArithmeticExpression_1_0 returns BooleanLiteral
	 *     AtomicExpression returns BooleanLiteral
	 *     Literal returns BooleanLiteral
	 *     BooleanLiteral returns BooleanLiteral
	 *
	 * Constraint:
	 *     (value?='TRUE' | value?='FALSE')
	 */
	protected void sequence_BooleanLiteral(ISerializationContext context, BooleanLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ColumnReference
	 *     OrExpression returns ColumnReference
	 *     OrExpression.BinaryLogicalExpression_1_0 returns ColumnReference
	 *     AndExpression returns ColumnReference
	 *     AndExpression.BinaryLogicalExpression_1_0 returns ColumnReference
	 *     AndOperand returns ColumnReference
	 *     ComparativeExpression returns ColumnReference
	 *     ComparativeExpression.ComparativeExpression_1_0 returns ColumnReference
	 *     AdditiveExpression returns ColumnReference
	 *     AdditiveExpression.ArithmeticExpression_1_0 returns ColumnReference
	 *     MultiplicativeExpression returns ColumnReference
	 *     MultiplicativeExpression.ArithmeticExpression_1_0 returns ColumnReference
	 *     AtomicExpression returns ColumnReference
	 *     ColumnReference returns ColumnReference
	 *
	 * Constraint:
	 *     column=[Column|ID]
	 */
	protected void sequence_ColumnReference(ISerializationContext context, ColumnReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QueryPackage.Literals.COLUMN_REFERENCE__COLUMN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QueryPackage.Literals.COLUMN_REFERENCE__COLUMN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getColumnReferenceAccess().getColumnColumnIDTerminalRuleCall_0_1(), semanticObject.eGet(QueryPackage.Literals.COLUMN_REFERENCE__COLUMN, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ComparativeExpression
	 *     OrExpression returns ComparativeExpression
	 *     OrExpression.BinaryLogicalExpression_1_0 returns ComparativeExpression
	 *     AndExpression returns ComparativeExpression
	 *     AndExpression.BinaryLogicalExpression_1_0 returns ComparativeExpression
	 *     AndOperand returns ComparativeExpression
	 *     ComparativeExpression returns ComparativeExpression
	 *     ComparativeExpression.ComparativeExpression_1_0 returns ComparativeExpression
	 *     AdditiveExpression returns ComparativeExpression
	 *     AdditiveExpression.ArithmeticExpression_1_0 returns ComparativeExpression
	 *     MultiplicativeExpression returns ComparativeExpression
	 *     MultiplicativeExpression.ArithmeticExpression_1_0 returns ComparativeExpression
	 *     AtomicExpression returns ComparativeExpression
	 *
	 * Constraint:
	 *     (expression1=ComparativeExpression_ComparativeExpression_1_0 operator=ComparativeOperator expression2=AdditiveExpression)
	 */
	protected void sequence_ComparativeExpression(ISerializationContext context, ComparativeExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QueryPackage.Literals.BINARY__EXPRESSION1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QueryPackage.Literals.BINARY__EXPRESSION1));
			if (transientValues.isValueTransient(semanticObject, QueryPackage.Literals.COMPARATIVE_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QueryPackage.Literals.COMPARATIVE_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, QueryPackage.Literals.BINARY__EXPRESSION2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QueryPackage.Literals.BINARY__EXPRESSION2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparativeExpressionAccess().getComparativeExpressionExpression1Action_1_0(), semanticObject.getExpression1());
		feeder.accept(grammarAccess.getComparativeExpressionAccess().getOperatorComparativeOperatorEnumRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getComparativeExpressionAccess().getExpression2AdditiveExpressionParserRuleCall_1_2_0(), semanticObject.getExpression2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FromClause returns FromClause
	 *
	 * Constraint:
	 *     tableReference=TableReference
	 */
	protected void sequence_FromClause(ISerializationContext context, FromClause semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QueryPackage.Literals.FROM_CLAUSE__TABLE_REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QueryPackage.Literals.FROM_CLAUSE__TABLE_REFERENCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFromClauseAccess().getTableReferenceTableReferenceParserRuleCall_1_0(), semanticObject.getTableReference());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IntegerLiteral
	 *     OrExpression returns IntegerLiteral
	 *     OrExpression.BinaryLogicalExpression_1_0 returns IntegerLiteral
	 *     AndExpression returns IntegerLiteral
	 *     AndExpression.BinaryLogicalExpression_1_0 returns IntegerLiteral
	 *     AndOperand returns IntegerLiteral
	 *     ComparativeExpression returns IntegerLiteral
	 *     ComparativeExpression.ComparativeExpression_1_0 returns IntegerLiteral
	 *     AdditiveExpression returns IntegerLiteral
	 *     AdditiveExpression.ArithmeticExpression_1_0 returns IntegerLiteral
	 *     MultiplicativeExpression returns IntegerLiteral
	 *     MultiplicativeExpression.ArithmeticExpression_1_0 returns IntegerLiteral
	 *     AtomicExpression returns IntegerLiteral
	 *     Literal returns IntegerLiteral
	 *     IntegerLiteral returns IntegerLiteral
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_IntegerLiteral(ISerializationContext context, IntegerLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QueryPackage.Literals.INTEGER_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QueryPackage.Literals.INTEGER_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegerLiteralAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns UnaryLogicalExpression
	 *     OrExpression returns UnaryLogicalExpression
	 *     OrExpression.BinaryLogicalExpression_1_0 returns UnaryLogicalExpression
	 *     AndExpression returns UnaryLogicalExpression
	 *     AndExpression.BinaryLogicalExpression_1_0 returns UnaryLogicalExpression
	 *     AndOperand returns UnaryLogicalExpression
	 *     NotExpression returns UnaryLogicalExpression
	 *     ComparativeExpression returns UnaryLogicalExpression
	 *     ComparativeExpression.ComparativeExpression_1_0 returns UnaryLogicalExpression
	 *     AdditiveExpression returns UnaryLogicalExpression
	 *     AdditiveExpression.ArithmeticExpression_1_0 returns UnaryLogicalExpression
	 *     MultiplicativeExpression returns UnaryLogicalExpression
	 *     MultiplicativeExpression.ArithmeticExpression_1_0 returns UnaryLogicalExpression
	 *     AtomicExpression returns UnaryLogicalExpression
	 *
	 * Constraint:
	 *     (operator=NotOperator expression=ComparativeExpression)
	 */
	protected void sequence_NotExpression(ISerializationContext context, UnaryLogicalExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QueryPackage.Literals.LOGICAL_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QueryPackage.Literals.LOGICAL_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, QueryPackage.Literals.UNARY__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QueryPackage.Literals.UNARY__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotExpressionAccess().getOperatorNotOperatorEnumRuleCall_0_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getNotExpressionAccess().getExpressionComparativeExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OrderByClause returns OrderByClause
	 *
	 * Constraint:
	 *     (orderDirectives+=OrderDirective orderDirectives+=OrderDirective*)
	 */
	protected void sequence_OrderByClause(ISerializationContext context, OrderByClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OrderDirective returns OrderDirective
	 *
	 * Constraint:
	 *     (columnReference=ColumnReference (ascending?='ASC' | ascending?='DESC')?)
	 */
	protected void sequence_OrderDirective(ISerializationContext context, OrderDirective semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SelectQuery returns SelectQuery
	 *
	 * Constraint:
	 *     (whatClause=WhatClause fromClause=FromClause whereClause=WhereClause? orderByClause=OrderByClause?)
	 */
	protected void sequence_SelectQuery(ISerializationContext context, SelectQuery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WhatDirective returns SingleColumnWhatDirective
	 *     SingleColumnWhatDirective returns SingleColumnWhatDirective
	 *
	 * Constraint:
	 *     columnReference=ColumnReference
	 */
	protected void sequence_SingleColumnWhatDirective(ISerializationContext context, SingleColumnWhatDirective semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QueryPackage.Literals.SINGLE_COLUMN_WHAT_DIRECTIVE__COLUMN_REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QueryPackage.Literals.SINGLE_COLUMN_WHAT_DIRECTIVE__COLUMN_REFERENCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSingleColumnWhatDirectiveAccess().getColumnReferenceColumnReferenceParserRuleCall_0(), semanticObject.getColumnReference());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns StringLiteral
	 *     OrExpression returns StringLiteral
	 *     OrExpression.BinaryLogicalExpression_1_0 returns StringLiteral
	 *     AndExpression returns StringLiteral
	 *     AndExpression.BinaryLogicalExpression_1_0 returns StringLiteral
	 *     AndOperand returns StringLiteral
	 *     ComparativeExpression returns StringLiteral
	 *     ComparativeExpression.ComparativeExpression_1_0 returns StringLiteral
	 *     AdditiveExpression returns StringLiteral
	 *     AdditiveExpression.ArithmeticExpression_1_0 returns StringLiteral
	 *     MultiplicativeExpression returns StringLiteral
	 *     MultiplicativeExpression.ArithmeticExpression_1_0 returns StringLiteral
	 *     AtomicExpression returns StringLiteral
	 *     Literal returns StringLiteral
	 *     StringLiteral returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QueryPackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QueryPackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TableReference returns TableReference
	 *
	 * Constraint:
	 *     table=[Table|ID]
	 */
	protected void sequence_TableReference(ISerializationContext context, TableReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QueryPackage.Literals.TABLE_REFERENCE__TABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QueryPackage.Literals.TABLE_REFERENCE__TABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTableReferenceAccess().getTableTableIDTerminalRuleCall_0_1(), semanticObject.eGet(QueryPackage.Literals.TABLE_REFERENCE__TABLE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     WhatClause returns WhatClause
	 *
	 * Constraint:
	 *     (whatDirectives+=WhatDirective whatDirectives+=WhatDirective*)
	 */
	protected void sequence_WhatClause(ISerializationContext context, WhatClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WhereClause returns WhereClause
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_WhereClause(ISerializationContext context, WhereClause semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QueryPackage.Literals.WHERE_CLAUSE__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QueryPackage.Literals.WHERE_CLAUSE__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhereClauseAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
}
