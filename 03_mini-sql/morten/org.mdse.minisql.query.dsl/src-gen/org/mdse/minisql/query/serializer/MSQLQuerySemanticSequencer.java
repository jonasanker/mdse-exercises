/*
 * generated by Xtext 2.20.0
 */
package org.mdse.minisql.query.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.mdse.minisql.query.AllColumnsWhatDirective;
import org.mdse.minisql.query.ArithmeticExpression;
import org.mdse.minisql.query.ColumnReference;
import org.mdse.minisql.query.ComparativeExpression;
import org.mdse.minisql.query.FromClause;
import org.mdse.minisql.query.IntegerLiteral;
import org.mdse.minisql.query.OrderByClause;
import org.mdse.minisql.query.OrderByDirective;
import org.mdse.minisql.query.QueryPackage;
import org.mdse.minisql.query.SelectQuery;
import org.mdse.minisql.query.SingleColumnWhatDirective;
import org.mdse.minisql.query.WhatClause;
import org.mdse.minisql.query.WhereClause;
import org.mdse.minisql.query.services.MSQLQueryGrammarAccess;

@SuppressWarnings("all")
public class MSQLQuerySemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MSQLQueryGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == QueryPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case QueryPackage.ALL_COLUMNS_WHAT_DIRECTIVE:
				sequence_AllColumnsWhatDirective(context, (AllColumnsWhatDirective) semanticObject); 
				return; 
			case QueryPackage.ARITHMETIC_EXPRESSION:
				sequence_AdditiveExpression_MultiplicativeExpression(context, (ArithmeticExpression) semanticObject); 
				return; 
			case QueryPackage.COLUMN_REFERENCE:
				sequence_ColumnReference(context, (ColumnReference) semanticObject); 
				return; 
			case QueryPackage.COMPARATIVE_EXPRESSION:
				sequence_ComparativeExpression(context, (ComparativeExpression) semanticObject); 
				return; 
			case QueryPackage.FROM_CLAUSE:
				sequence_FromClause(context, (FromClause) semanticObject); 
				return; 
			case QueryPackage.INTEGER_LITERAL:
				sequence_IntegerLiteral(context, (IntegerLiteral) semanticObject); 
				return; 
			case QueryPackage.ORDER_BY_CLAUSE:
				sequence_OrderByClause(context, (OrderByClause) semanticObject); 
				return; 
			case QueryPackage.ORDER_BY_DIRECTIVE:
				sequence_OrderByDirective(context, (OrderByDirective) semanticObject); 
				return; 
			case QueryPackage.SELECT_QUERY:
				sequence_SelectQuery(context, (SelectQuery) semanticObject); 
				return; 
			case QueryPackage.SINGLE_COLUMN_WHAT_DIRECTIVE:
				sequence_SingleColumnWhatDirective(context, (SingleColumnWhatDirective) semanticObject); 
				return; 
			case QueryPackage.WHAT_CLAUSE:
				sequence_WhatClause(context, (WhatClause) semanticObject); 
				return; 
			case QueryPackage.WHERE_CLAUSE:
				sequence_WhereClause(context, (WhereClause) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expression returns ArithmeticExpression
	 *     AdditiveExpression returns ArithmeticExpression
	 *     AdditiveExpression.ArithmeticExpression_1_0 returns ArithmeticExpression
	 *     MultiplicativeExpression returns ArithmeticExpression
	 *     MultiplicativeExpression.ArithmeticExpression_1_0 returns ArithmeticExpression
	 *     ComparativeExpression returns ArithmeticExpression
	 *     ComparativeExpression.ComparativeExpression_1_0 returns ArithmeticExpression
	 *     AtomicExpression returns ArithmeticExpression
	 *
	 * Constraint:
	 *     (
	 *         (expression1=AdditiveExpression_ArithmeticExpression_1_0 operator=AdditiveOperator expression2=MultiplicativeExpression) | 
	 *         (expression1=MultiplicativeExpression_ArithmeticExpression_1_0 operator=MultiplicativeOperator expression2=AtomicExpression)
	 *     )
	 */
	protected void sequence_AdditiveExpression_MultiplicativeExpression(ISerializationContext context, ArithmeticExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WhatDirective returns AllColumnsWhatDirective
	 *     AllColumnsWhatDirective returns AllColumnsWhatDirective
	 *
	 * Constraint:
	 *     {AllColumnsWhatDirective}
	 */
	protected void sequence_AllColumnsWhatDirective(ISerializationContext context, AllColumnsWhatDirective semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ColumnReference
	 *     AdditiveExpression returns ColumnReference
	 *     AdditiveExpression.ArithmeticExpression_1_0 returns ColumnReference
	 *     MultiplicativeExpression returns ColumnReference
	 *     MultiplicativeExpression.ArithmeticExpression_1_0 returns ColumnReference
	 *     ComparativeExpression returns ColumnReference
	 *     ComparativeExpression.ComparativeExpression_1_0 returns ColumnReference
	 *     AtomicExpression returns ColumnReference
	 *     ColumnReference returns ColumnReference
	 *
	 * Constraint:
	 *     column=[Column|ID]
	 */
	protected void sequence_ColumnReference(ISerializationContext context, ColumnReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QueryPackage.Literals.COLUMN_REFERENCE__COLUMN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QueryPackage.Literals.COLUMN_REFERENCE__COLUMN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getColumnReferenceAccess().getColumnColumnIDTerminalRuleCall_0_1(), semanticObject.eGet(QueryPackage.Literals.COLUMN_REFERENCE__COLUMN, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ComparativeExpression
	 *     AdditiveExpression returns ComparativeExpression
	 *     AdditiveExpression.ArithmeticExpression_1_0 returns ComparativeExpression
	 *     MultiplicativeExpression returns ComparativeExpression
	 *     MultiplicativeExpression.ArithmeticExpression_1_0 returns ComparativeExpression
	 *     ComparativeExpression returns ComparativeExpression
	 *     ComparativeExpression.ComparativeExpression_1_0 returns ComparativeExpression
	 *     AtomicExpression returns ComparativeExpression
	 *
	 * Constraint:
	 *     (expression1=ComparativeExpression_ComparativeExpression_1_0 operator=ComparativeOperator expression2=AdditiveExpression)
	 */
	protected void sequence_ComparativeExpression(ISerializationContext context, ComparativeExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QueryPackage.Literals.COMPARATIVE_EXPRESSION__EXPRESSION1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QueryPackage.Literals.COMPARATIVE_EXPRESSION__EXPRESSION1));
			if (transientValues.isValueTransient(semanticObject, QueryPackage.Literals.COMPARATIVE_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QueryPackage.Literals.COMPARATIVE_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, QueryPackage.Literals.COMPARATIVE_EXPRESSION__EXPRESSION2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QueryPackage.Literals.COMPARATIVE_EXPRESSION__EXPRESSION2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparativeExpressionAccess().getComparativeExpressionExpression1Action_1_0(), semanticObject.getExpression1());
		feeder.accept(grammarAccess.getComparativeExpressionAccess().getOperatorComparativeOperatorEnumRuleCall_1_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getComparativeExpressionAccess().getExpression2AdditiveExpressionParserRuleCall_1_2_0(), semanticObject.getExpression2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FromClause returns FromClause
	 *
	 * Constraint:
	 *     table=[Table|ID]
	 */
	protected void sequence_FromClause(ISerializationContext context, FromClause semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QueryPackage.Literals.FROM_CLAUSE__TABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QueryPackage.Literals.FROM_CLAUSE__TABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFromClauseAccess().getTableTableIDTerminalRuleCall_1_0_1(), semanticObject.eGet(QueryPackage.Literals.FROM_CLAUSE__TABLE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IntegerLiteral
	 *     AdditiveExpression returns IntegerLiteral
	 *     AdditiveExpression.ArithmeticExpression_1_0 returns IntegerLiteral
	 *     MultiplicativeExpression returns IntegerLiteral
	 *     MultiplicativeExpression.ArithmeticExpression_1_0 returns IntegerLiteral
	 *     ComparativeExpression returns IntegerLiteral
	 *     ComparativeExpression.ComparativeExpression_1_0 returns IntegerLiteral
	 *     AtomicExpression returns IntegerLiteral
	 *     IntegerLiteral returns IntegerLiteral
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_IntegerLiteral(ISerializationContext context, IntegerLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QueryPackage.Literals.INTEGER_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QueryPackage.Literals.INTEGER_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegerLiteralAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OrderByClause returns OrderByClause
	 *
	 * Constraint:
	 *     (orderDirectives+=OrderByDirective orderDirectives+=OrderByDirective*)
	 */
	protected void sequence_OrderByClause(ISerializationContext context, OrderByClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OrderByDirective returns OrderByDirective
	 *
	 * Constraint:
	 *     (columnReference+=ColumnReference (ascending?='ASC' | ascending?='DESC')?)
	 */
	protected void sequence_OrderByDirective(ISerializationContext context, OrderByDirective semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SelectQuery returns SelectQuery
	 *
	 * Constraint:
	 *     (whatClause+=WhatClause fromClause=FromClause whereClause=WhereClause? orderByClause=OrderByClause?)
	 */
	protected void sequence_SelectQuery(ISerializationContext context, SelectQuery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WhatDirective returns SingleColumnWhatDirective
	 *     SingleColumnWhatDirective returns SingleColumnWhatDirective
	 *
	 * Constraint:
	 *     columnReference=ColumnReference
	 */
	protected void sequence_SingleColumnWhatDirective(ISerializationContext context, SingleColumnWhatDirective semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, QueryPackage.Literals.SINGLE_COLUMN_WHAT_DIRECTIVE__COLUMN_REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, QueryPackage.Literals.SINGLE_COLUMN_WHAT_DIRECTIVE__COLUMN_REFERENCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSingleColumnWhatDirectiveAccess().getColumnReferenceColumnReferenceParserRuleCall_0(), semanticObject.getColumnReference());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     WhatClause returns WhatClause
	 *
	 * Constraint:
	 *     (whatDirective+=WhatDirective whatDirective+=WhatDirective*)
	 */
	protected void sequence_WhatClause(ISerializationContext context, WhatClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WhereClause returns WhereClause
	 *
	 * Constraint:
	 *     expression+=Expression
	 */
	protected void sequence_WhereClause(ISerializationContext context, WhereClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
